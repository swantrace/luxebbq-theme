{"id":"../node_modules/@apollo-elements/interfaces/apollo-mutation.js","dependencies":[{"name":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/apollo-mutation.js.map","includedInParent":true,"mtime":1614903032567},{"name":"/home/qhong/projects/luxebbq/theme/package.json","includedInParent":true,"mtime":1614946696316},{"name":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/package.json","includedInParent":true,"mtime":1614903032567},{"name":"@apollo-elements/mixins/apollo-mutation-mixin","loc":{"line":1,"column":36},"parent":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/apollo-mutation.js","resolved":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/mixins/apollo-mutation-mixin.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloMutationElement = void 0;\n\nvar _apolloMutationMixin = require(\"@apollo-elements/mixins/apollo-mutation-mixin\");\n\nclass ApolloMutationElement extends (0, _apolloMutationMixin.ApolloMutationMixin)(HTMLElement) {}\n\nexports.ApolloMutationElement = ApolloMutationElement;"},"sourceMaps":{"js":{"mappings":[{"source":"apollo-mutation.ts","name":null,"original":{"line":16,"column":0},"generated":{"line":8,"column":0}},{"source":"apollo-mutation.ts","name":null,"original":{"line":142,"column":6},"generated":{"line":10,"column":0}},{"source":"apollo-mutation.ts","name":null,"original":{"line":142,"column":13},"generated":{"line":10,"column":6}},{"source":"apollo-mutation.ts","name":null,"original":{"line":142,"column":6},"generated":{"line":10,"column":27}},{"source":"apollo-mutation.ts","name":null,"original":{"line":143,"column":10},"generated":{"line":10,"column":36}},{"source":"apollo-mutation.ts","name":null,"original":{"line":143,"column":30},"generated":{"line":10,"column":82}},{"source":"apollo-mutation.ts","name":null,"original":{"line":143,"column":10},"generated":{"line":10,"column":93}},{"source":"apollo-mutation.ts","name":null,"original":{"line":142,"column":6},"generated":{"line":10,"column":94}},{"source":"apollo-mutation.ts","name":null,"original":{"line":143,"column":48},"generated":{"line":10,"column":95}}],"sources":{"apollo-mutation.ts":"import type {\n  DocumentNode,\n  ErrorPolicy,\n  FetchPolicy,\n  FetchResult,\n  MutationOptions,\n  MutationUpdaterFn,\n  OperationVariables,\n} from '@apollo/client/core';\n\nimport type { RefetchQueryDescription } from '@apollo/client/core/watchQueryOptions';\n\nimport type { ComponentDocument, Data, Variables } from './operation';\nimport type { ApolloElementInterface } from './apollo-element';\n\nimport { ApolloMutationMixin } from '@apollo-elements/mixins/apollo-mutation-mixin';\n\nexport type RefetchQueriesType<D> =\n  RefetchQueryDescription |\n  ((result: FetchResult<Data<D>>) =>\n    RefetchQueryDescription);\n\nexport type OptimisticResponseType<D, V> =\n  Data<D> |\n  ((vars: Variables<D, V>) =>\n    Data<D>);\n\n/**\n * Common interface for mutation elements\n *\n * See [`ApolloElementInterface`](https://apolloelements.dev/api/interfaces/element) for more information on events\n *\n * @element\n *\n * @fires 'apollo-mutation-result' when the mutation resolves\n * @fires 'apollo-error' when the mutation rejects\n */\nexport declare class ApolloMutationInterface<D, V = OperationVariables>\n  extends ApolloElementInterface {\n  /**\n   * Latest mutation data\n   */\n  declare data: Data<D> | null;\n\n  /**\n   * An object that maps from the name of a variable as used in the mutation GraphQL document to that variable's value.\n   *\n   * @summary Mutation variables.\n   */\n  declare variables: Variables<D, V> | null;\n\n  /** The mutation. */\n  declare mutation: DocumentNode | ComponentDocument<D> | null;\n\n  /**\n   * An object that represents the result of this mutation that\n   * will be optimistically stored before the server has actually returned a\n   * result.\n   *\n   * This is most often used for optimistic UI, where we want to be able to see\n   * the result of a mutation immediately, and update the UI later if any errors\n   * appear.\n   */\n  declare optimisticResponse?: OptimisticResponseType<D, V>;\n\n  /**\n   * Whether the mutation was called\n   */\n  declare called: boolean;\n\n  /**\n   * If true, the returned data property will not update with the mutation result.\n   */\n  declare ignoreResults?: boolean;\n\n  /**\n   * Specifies the ErrorPolicy to be used for this mutation.\n   */\n  declare errorPolicy?: ErrorPolicy;\n\n  /**\n   * Specifies the FetchPolicy to be used for this mutation.\n   */\n  declare fetchPolicy?: Extract<FetchPolicy, 'no-cache'>;\n\n  /**\n   * A list of query names which will be refetched once this mutation has returned.\n   * This is often used if you have a set of queries which may be affected by a mutation and will have to update.\n   * Rather than writing a mutation query reducer (i.e. `updateQueries`) for this,\n   * you can refetch the queries that will be affected\n   * and achieve a consistent store once these queries return.\n   */\n  declare refetchQueries: RefetchQueriesType<D> | null;\n\n  /**\n   * Queries refetched as part of refetchQueries are handled asynchronously,\n   * and are not waited on before the mutation is completed (resolved).\n   * Setting this to true will make sure refetched queries are completed\n   * before the mutation is considered done. false by default.\n   */\n  declare awaitRefetchQueries?: boolean;\n\n  constructor(...a: any[]);\n\n  /**\n   * Callback for when a mutation is completed.\n   */\n  onCompleted?(_data: Data<D>): void\n\n  /**\n   * Callback for when an error occurs in mutation.\n   */\n  onError?(_error: Error): void\n\n  /**\n   * A function which updates the apollo cache when the query responds.\n   * This function will be called twice over the lifecycle of a mutation.\n   * Once at the very beginning if an optimisticResponse was provided.\n   * The writes created from the optimistic data will be rolled back before\n   * the second time this function is called which is when the mutation has\n   * succesfully resolved. At that point update will be called with the actual\n   * mutation result and those writes will not be rolled back.\n   *\n   * The reason a DataProxy is provided instead of the user calling the methods\n   * directly on ApolloClient is that all of the writes are batched together at\n   * the end of the update, and it allows for writes generated by optimistic\n   * data to be rolled back.\n   */\n  updater?(\n    ...params: Parameters<MutationUpdaterFn<Data<D>>>\n  ): ReturnType<MutationUpdaterFn<Data<D>>>;\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an error.\n   */\n  public mutate(\n    params?: Partial<MutationOptions<Data<D>, Variables<D, V>>>\n  ): Promise<FetchResult<Data<D>>>;\n}\n\nexport class ApolloMutationElement<D = unknown, V = OperationVariables>\n  extends ApolloMutationMixin(HTMLElement)<D, V> implements ApolloMutationInterface<D, V> {\n    declare data: Data<D> | null;\n\n    declare variables: Variables<D, V> | null;\n}\n"},"lineCount":null}},"error":null,"hash":"fc7ba6c72bd7664b05b62dda5b2e838c","cacheData":{"env":{}}}