{"id":"../node_modules/@apollo-elements/interfaces/apollo-query.js","dependencies":[{"name":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/apollo-query.js.map","includedInParent":true,"mtime":1614903032567},{"name":"/home/qhong/projects/luxebbq/theme/package.json","includedInParent":true,"mtime":1614903197160},{"name":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/package.json","includedInParent":true,"mtime":1614903032567},{"name":"@apollo-elements/mixins/apollo-query-mixin","loc":{"line":1,"column":33},"parent":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/interfaces/apollo-query.js","resolved":"/home/qhong/projects/luxebbq/theme/node_modules/@apollo-elements/mixins/apollo-query-mixin.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloQueryElement = void 0;\n\nvar _apolloQueryMixin = require(\"@apollo-elements/mixins/apollo-query-mixin\");\n\nclass ApolloQueryElement extends (0, _apolloQueryMixin.ApolloQueryMixin)(HTMLElement) {}\n\nexports.ApolloQueryElement = ApolloQueryElement;"},"sourceMaps":{"js":{"mappings":[{"source":"apollo-query.ts","name":null,"original":{"line":20,"column":0},"generated":{"line":8,"column":0}},{"source":"apollo-query.ts","name":null,"original":{"line":254,"column":6},"generated":{"line":10,"column":0}},{"source":"apollo-query.ts","name":null,"original":{"line":254,"column":13},"generated":{"line":10,"column":6}},{"source":"apollo-query.ts","name":null,"original":{"line":254,"column":6},"generated":{"line":10,"column":24}},{"source":"apollo-query.ts","name":null,"original":{"line":255,"column":10},"generated":{"line":10,"column":33}},{"source":"apollo-query.ts","name":null,"original":{"line":255,"column":27},"generated":{"line":10,"column":73}},{"source":"apollo-query.ts","name":null,"original":{"line":255,"column":10},"generated":{"line":10,"column":84}},{"source":"apollo-query.ts","name":null,"original":{"line":254,"column":6},"generated":{"line":10,"column":85}},{"source":"apollo-query.ts","name":null,"original":{"line":255,"column":45},"generated":{"line":10,"column":86}}],"sources":{"apollo-query.ts":"import type {\n  ApolloQueryResult,\n  DocumentNode,\n  ErrorPolicy,\n  FetchPolicy,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  NetworkStatus,\n  ObservableQuery,\n  OperationVariables,\n  QueryOptions,\n  SubscribeToMoreOptions,\n  SubscriptionOptions,\n  WatchQueryOptions,\n} from '@apollo/client/core';\n\nimport type { ComponentDocument, Data, Variables } from './operation';\nimport type { ApolloElementInterface } from './apollo-element';\n\nimport { ApolloQueryMixin } from '@apollo-elements/mixins/apollo-query-mixin';\n\nexport type FetchMoreParams<D, V> =\n  FetchMoreQueryOptions<Variables<D, V>, keyof Variables<D, V>, Data<D>> &\n  FetchMoreOptions<Data<D>, Variables<D, V>>\n\n/**\n * Common interface for query elements\n *\n * See [`ApolloElementInterface`](https://apolloelements.dev/api/interfaces/element) for more information on events\n *\n * @element\n *\n * @fires 'apollo-query-result' when the query resolves\n * @fires 'apollo-error' when the query rejects\n */\nexport declare class ApolloQueryInterface<D, V = OperationVariables>\n  extends ApolloElementInterface\n  implements ApolloQueryInterface<D, V> {\n  static documentType: 'query';\n\n  /**\n   * The latest query data.\n   */\n  declare data: Data<D> | null;\n\n  /**\n   * A GraphQL document containing a single query.\n   */\n  declare query: DocumentNode | ComponentDocument<D> | null;\n\n  /**\n   * An object map from variable name to variable value, where the variables are used within the GraphQL query.\n   *\n   * Setting variables will initiate the query, unless [`noAutoSubscribe`](#noautosubscribe) is also set.\n   *\n   * @summary Query variables.\n   */\n  declare variables: Variables<D, V> | null;\n\n  /**\n   * Determines where the client may return a result from. The options are:\n   *\n   * - `cache-first` (default): return result from cache, fetch from network if cached result is not available.\n   * - `cache-and-network`: return result from cache first (if it exists), then return network result once it's available.\n   * - `cache-only`: return result from cache if available, fail otherwise.\n   * - `no-cache`: return result from network, fail if network call doesn't succeed, don't save to cache\n   * - `network-only`: return result from network, fail if network call doesn't succeed, save to cache\n   * - `standby`: only for queries that aren't actively watched, but should be available for refetch and updateQueries.\n   *\n   * @summary The [fetchPolicy](https://www.apollographql.com/docs/react/api/core/ApolloClient/#FetchPolicy) for the query.\n   */\n  declare fetchPolicy?: FetchPolicy;\n\n  /**\n   * When someone chooses cache-and-network or network-only as their\n   * initial FetchPolicy, they often do not want future cache updates to\n   * trigger unconditional network requests, which is what repeatedly\n   * applying the cache-and-network or network-only policies would seem\n   * to imply. Instead, when the cache reports an update after the\n   * initial network request, it may be desirable for subsequent network\n   * requests to be triggered only if the cache result is incomplete.\n   * The nextFetchPolicy option provides a way to update\n   * options.fetchPolicy after the intial network request, without\n   * having to set options.\n   *\n   * @summary Set to prevent subsequent network requests when the fetch policy is `cache-and-network` or `network-only`.\n   */\n  declare nextFetchPolicy?: FetchPolicy;\n\n  /**\n   * If data was read from the cache with missing fields,\n   * partial will be true. Otherwise, partial will be falsy.\n   *\n   * @summary True when the query returned partial data.\n   */\n  declare partial?: boolean;\n\n  /**\n   * If true, perform a query refetch if the query result is marked as being partial,\n   * and the returned data is reset to an empty Object by the Apollo Client QueryManager\n   * (due to a cache miss).\n   *\n   * The default value is false for backwards-compatibility's sake,\n   * but should be changed to true for most use-cases.\n   *\n   * @summary Set to retry any partial query results.\n   */\n  declare partialRefetch?: boolean;\n\n  /**\n   * Opt into receiving partial results from the cache for queries\n   * that are not fully satisfied by the cache.\n   */\n  declare returnPartialData?: boolean;\n\n  /**\n   * `networkStatus` is useful if you want to display a different loading indicator (or no indicator at all)\n   * depending on your network status as it provides a more detailed view into the state of a network request\n   * on your component than `loading` does. `networkStatus` is an enum with different number values between 1 and 8.\n   * These number values each represent a different network state.\n   *\n   * 1. `loading`: The query has never been run before and the request is now pending. A query will still have this network status even if a result was returned from the cache, but a query was dispatched anyway.\n   * 2. `setVariables`: If a queryâ€™s variables change and a network request was fired then the network status will be setVariables until the result of that query comes back. React users will see this when options.variables changes on their queries.\n   * 3. `fetchMore`: Indicates that fetchMore was called on this query and that the network request created is currently in flight.\n   * 4. `refetch`: It means that refetch was called on a query and the refetch request is currently in flight.\n   * 5. Unused.\n   * 6. `poll`: Indicates that a polling query is currently in flight. So for example if you are polling a query every 10 seconds then the network status will switch to poll every 10 seconds whenever a poll request has been sent but not resolved.\n   * 7. `ready`: No request is in flight for this query, and no errors happened. Everything is OK.\n   * 8. `error`: No request is in flight for this query, but one or more errors were detected.\n   *\n   * If the network status is less then 7 then it is equivalent to `loading` being true. In fact you could\n   * replace all of your `loading` checks with `networkStatus < 7` and you would not see a difference.\n   * It is recommended that you use `loading`, however.\n   */\n  declare networkStatus: NetworkStatus;\n\n  /**\n   * The Apollo `ObservableQuery` watching this element's query.\n   */\n  declare observableQuery?: ObservableQuery<Data<D>, Variables<D, V>>;\n\n  /**\n   * Set to reobserve the `ObservableQuery`\n   */\n  declare options: Partial<WatchQueryOptions<Variables<D, V>, Data<D>>> | null;\n\n  /**\n   * Whether or not updates to the network status should trigger next on the observer of this query.\n   */\n  declare notifyOnNetworkStatusChange?: boolean;\n\n  /**\n   * The time interval (in milliseconds) on which this query should be refetched from the server.\n   */\n  declare pollInterval?: number;\n\n  /**\n   * errorPolicy determines the level of events for errors in the execution result. The options are:\n   * - `none` (default): any errors from the request are treated like runtime errors and the observable is stopped (XXX this is default to lower breaking changes going from AC 1.0 => 2.0)\n   * - `ignore`: errors from the request do not stop the observable, but also don't call `next`\n   * - `all`: errors are treated like data and will notify observables\n   */\n  declare errorPolicy: ErrorPolicy;\n\n  /**\n   * When true, the component will not automatically subscribe to new data.\n   * Call the `subscribe()` method to do so.\n   */\n  declare noAutoSubscribe: boolean;\n\n  /** Flags an element that's ready and able to auto subscribe */\n  public get canAutoSubscribe(): boolean;\n\n  constructor(...a: any[]);\n\n  /**\n   * Optional callback for when a query is completed.\n   */\n  onData?(_result: ApolloQueryResult<Data<D>>): void\n\n  /**\n   * Optional callback for when an error occurs.\n   */\n  onError?(_error: Error): void\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * @param variables The new set of variables. If there are missing variables, the previous values of those variables will be used..\n   */\n  refetch(variables: Variables<D, V>): Promise<ApolloQueryResult<Data<D>>>;\n\n  /**\n   * Determines whether the element should attempt to subscribe i.e. begin querying\n   * Override to prevent subscribing unless your conditions are met\n   * @override\n   */\n  shouldSubscribe(\n    options?: Partial<SubscriptionOptions<Variables<D, V>, Data<D>>>\n  ): boolean\n\n  /**\n   * Resets the observableQuery and subscribes.\n   */\n  subscribe(\n    params?: Partial<SubscriptionOptions<Variables<D, V>, Data<D>>>\n  ): ZenObservable.Subscription;\n\n  /**\n   * Lets you pass a GraphQL subscription and updateQuery function\n   * to subscribe to more updates for your query.\n   *\n   * The `updateQuery` parameter is a function that takes the previous query data,\n   * then a `{ subscriptionData: TSubscriptionResult }` object,\n   * and returns an object with updated query data based on the new results.\n   */\n  subscribeToMore(options: SubscribeToMoreOptions<Data<D>, Variables<D, V>>): (() => void) | void;\n\n  /**\n   * Executes a Query once and updates the component with the result\n   */\n  executeQuery(\n    params?: Partial<QueryOptions<Variables<D, V>>>\n  ): Promise<ApolloQueryResult<Data<D>> | void>;\n\n  /**\n   * Exposes the `ObservableQuery#fetchMore` method.\n   * https://www.apollographql.com/docs/react/api/core/ObservableQuery/#ObservableQuery.fetchMore\n   *\n   * The optional `updateQuery` parameter is a function that takes the previous query data,\n   * then a `{ subscriptionData: TSubscriptionResult }` object,\n   * and returns an object with updated query data based on the new results.\n   *\n   * The optional `variables` parameter is an optional new variables object.\n   */\n  fetchMore(params?: Partial<FetchMoreParams<D, V>>): Promise<ApolloQueryResult<Data<D>>>;\n\n  /**\n   * Creates an instance of ObservableQuery with the options provided by the element.\n   * - `context` Context to be passed to link execution chain\n   * - `errorPolicy` Specifies the ErrorPolicy to be used for this query\n   * - `fetchPolicy` Specifies the FetchPolicy to be used for this query\n   * - `fetchResults` Whether or not to fetch results\n   * - `metadata` Arbitrary metadata stored in the store with this query. Designed for debugging, developer tools, etc.\n   * - `notifyOnNetworkStatusChange` Whether or not updates to the network status should trigger next on the observer of this query\n   * - `pollInterval` The time interval (in milliseconds) on which this query should be refetched from the server.\n   * - `query` A GraphQL document that consists of a single query to be sent down to the server.\n   * - `variables` A map going from variable name to variable value, where the variables are used within the GraphQL query.\n   */\n  watchQuery(\n    options?: Partial<WatchQueryOptions<Variables<D, V>, Data<D>>>\n  ): ObservableQuery<Data<D>, Variables<D, V>>;\n}\n\nexport class ApolloQueryElement<D = unknown, V = OperationVariables>\n  extends ApolloQueryMixin(HTMLElement)<D, V> {\n}\n"},"lineCount":null}},"error":null,"hash":"99362448a3a9e7ff98bd78a729e9d289","cacheData":{"env":{}}}